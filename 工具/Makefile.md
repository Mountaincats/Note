1. 如果make执行的命令前面加了@字符，则不显示命令本身而只显示它的结果；通常make执行的命令如果出错（该命令的退出状态非0）就立刻终止，不再执行后续命令，但如果命令前面加了-号，即使这条命令出错，make也会继续执行后续命令。通常rm命令和mkdir命令前面要加-号，因为rm要删除的文件可能不存在，mkdir要创建的目录可能已存在，这两个命令都有可能出错，但这种错误是应该忽略的。例如上面已经执行过一遍make clean，再执行一遍就没有文件可删了，这时rm会报错，但make忽略这一错误，继续执行后面的echo命令
   ```makefile
    clean:
        @echo "cleanning project"
        -rm main *.o
        @echo "clean completed"
    .PHONY: clean
    ```

2. 
* $@，表示规则中的目标。
* $<，表示规则中的第一个条件。
* $?，表示规则中所有比目标新的条件，组成一个列表，以空格分隔。
* $^，表示规则中的所有条件，组成一个列表，以空格分隔。



3. 
* CC C编译器的名字，缺省值是cc。
* CFLAGS C编译器的选项，没有定义。
* CPP C预处理器的名字，缺省值是$(CC) -E。
* CPPFLAGS C预处理器的选项，没有定义。
* OUTPUT_OPTION 输出的命令行选项，缺省值是-o $@。
* RM 删除命令的名字，缺省值是rm -f。

4. 确定文件依赖头文件
   ```bash
   gcc -M *.c
   如果我们不需要输出系统头文件的依赖关系，可以用-MM选项
   gcc -MM *.c
   ```

5. 常用的make命令行选项
   * -n选项只打印要执行的命令，而不会真的执行命令，这个选项有助于我们检查Makefile写得是否正确，由于Makefile不是顺序执行的，用这个选项可以先看看命令的执行顺序，确认无误了再真正执行命令
   * -C选项可以切换到另一个目录执行那个目录下的Makefile，比如先退到上一级目录再执行我们的Makefile。一些规模较大的项目会把不同的模块或子系统的源代码放在不同的子目录中，然后在每个子目录下都写一个该目录的Makefile，然后在一个总的Makefile中用make -C命令执行每个子目录下的Makefile
   * 在make命令行也可以用=或:=定义变量，如果这次编译我想加调试选项-g，但我不想每次编译都加-g选项，可以在命令行定义CFLAGS变量，而不必修改Makefile编译完了再改回来
        ```bash
        make CFLAGS=-g
        ```
